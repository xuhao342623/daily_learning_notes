# 每日学习报告0926

今日学习成果

今日尝试使用c++编写一个控制节点，控制小车进行移动，并获得很大成果，

首先，我通过c++编写了一个简单的控制程序，控制小车往年某个方向移动，代码如下

```c++
#include <ros/ros.h>
#include <geometry_msgs/Twist.h>

int main(int argc, char *argv[])
{
    ros::init(argc , argv ,"vel_node");

    ros::NodeHandle n;
    ros::Publisher vel_pub = n.advertise<geometry_msgs::Twist>("/cmd_vel" , 10);

    geometry_msgs::Twist vel_msg;
    vel_msg.linear.x = 0.1;
    vel_msg.linear.y = 0;
    vel_msg.linear.z = 0;
    vel_msg.angular.x = 0;
    vel_msg.angular.y = 0;
    vel_msg.angular.z = 0;

    ros::Rate r(30);
    while (ros::ok())
    {
        vel_pub.publish(vel_msg);
        r.sleep();
        /* code */
    }

    return 0;

}
```

虽然只是简单的控制小车往x方向简单运动，但是我成功的从0-1的转变，第一次成功的在实物上发布节点信息

尤其是，小车的底层代码是使用python书写的，我成功的完成了c++与python的联通，

具体实现过程我通过，在小车的激光雷达避障程序中的launch文件中寻找车辆底盘控制的luanch文件，通过只启动地盘launch文件，然后rostopic list命令找到地盘程序的速度接受节点名字，然后在我的程序张发布相应的话题，成功的构建与地盘的联系

今日成功可以说是质的飞跃，从原来只会使用官方给的相应命令控制小车，到现在可以简单自主控制小车，

## 下一步学习计划

争取尽快完成对小车的地盘控制，通过研究官方的雷达避障程序然后，构建一个自己的简单雷达避障程序
